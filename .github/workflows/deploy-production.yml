name: Deploy to Production

on:
  push:
    branches: [main]
  workflow_dispatch:
    inputs:
      skip_tests:
        description: 'Skip tests (emergency deploy)'
        required: false
        default: 'false'

jobs:
  test:
    name: Run Tests
    runs-on: ubuntu-latest
    if: github.event.inputs.skip_tests != 'true'
    
    services:
      postgres:
        image: postgres:16
        env:
          POSTGRES_USER: postgres
          POSTGRES_PASSWORD: postgres
          POSTGRES_DB: connect_test
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
        ports:
          - 6432:5432
    
    env:
      DATABASE_URL: postgresql://postgres:postgres@localhost:6432/connect_test
      DIRECT_URL: postgresql://postgres:postgres@localhost:6432/connect_test
      NODE_ENV: test
      ENCRYPTION_KEY: 0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef
      NEXTAUTH_SECRET: test_nextauth_secret_for_ci_testing_only
      NEXTAUTH_URL: http://localhost:3000
      JWT_SECRET: test_jwt_secret_for_ci_testing_only
      NAVER_CLIENT_ID: test_naver_client_id_for_ci
      NAVER_CLIENT_SECRET: test_naver_client_secret_for_ci
      KAKAO_CLIENT_ID: test_kakao_client_id_for_ci
      KAKAO_CLIENT_SECRET: test_kakao_client_secret_for_ci
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20.x'
          cache: 'npm'
      
      - name: Install dependencies
        run: npm ci
      
      - name: Install PostgreSQL client
        run: |
          sudo apt-get update
          sudo apt-get install -y postgresql-client
      
      - name: Wait for PostgreSQL
        run: |
          echo "Waiting for PostgreSQL to be ready..."
          for i in {1..30}; do
            if pg_isready -h localhost -p 6432 -U postgres; then
              echo "✓ PostgreSQL is ready!"
              break
            fi
            echo "Attempt $i/30: PostgreSQL not ready yet..."
            sleep 2
          done
          
          # Verify connection
          PGPASSWORD=postgres psql -h localhost -p 6432 -U postgres -d connect_test -c "SELECT version();"
      
      - name: Setup test database
        run: |
          echo "Generating Prisma client..."
          npx prisma generate
          
          echo "Pushing database schema..."
          npx prisma db push --skip-generate --accept-data-loss
          
          echo "Verifying database schema..."
          PGPASSWORD=postgres psql -h localhost -p 6432 -U postgres -d connect_test -c "\dt"
          
          echo "✓ Database setup complete"
      
      - name: Verify environment
        run: |
          echo "DATABASE_URL: $DATABASE_URL"
          echo "NODE_ENV: $NODE_ENV"
          echo "Prisma client location:"
          ls -la node_modules/.prisma/client/ || echo "Prisma client not found"
      
      - name: Run tests
        env:
          DATABASE_URL: postgresql://postgres:postgres@localhost:6432/connect_test
          DIRECT_URL: postgresql://postgres:postgres@localhost:6432/connect_test
        run: npm test -- --passWithNoTests
      
      - name: Run linter
        run: npm run lint

  build:
    name: Build Docker Image
    runs-on: ubuntu-latest
    needs: test
    if: always() && (needs.test.result == 'success' || needs.test.result == 'skipped')
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3
      
      - name: Build production image
        uses: docker/build-push-action@v5
        with:
          context: .
          file: ./Dockerfile.production
          push: false
          tags: connect:${{ github.sha }}
          cache-from: type=gha
          cache-to: type=gha,mode=max
          outputs: type=docker,dest=/tmp/connect-image.tar
      
      - name: Upload image artifact
        uses: actions/upload-artifact@v4
        with:
          name: docker-image
          path: /tmp/connect-image.tar
          retention-days: 1

  deploy:
    name: Deploy to Production Server
    runs-on: ubuntu-latest
    needs: build
    environment:
      name: production
      url: https://221.164.102.253
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Download image artifact
        uses: actions/download-artifact@v4
        with:
          name: docker-image
          path: /tmp
      
      - name: Load Docker image
        run: docker load --input /tmp/connect-image.tar
      
      - name: Setup SSH key
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.PRODUCTION_SERVER_SSH_KEY }}" > ~/.ssh/deploy_key
          chmod 600 ~/.ssh/deploy_key
          ssh-keyscan -H ${{ secrets.PRODUCTION_SERVER_IP }} >> ~/.ssh/known_hosts
      
      - name: Copy image to production
        run: |
          docker save connect:${{ github.sha }} | gzip | \
          ssh -i ~/.ssh/deploy_key \
          ${{ secrets.PRODUCTION_SERVER_USER }}@${{ secrets.PRODUCTION_SERVER_IP }} \
          'gunzip | docker load'
      
      - name: Deploy to production
        run: |
          ssh -i ~/.ssh/deploy_key \
          ${{ secrets.PRODUCTION_SERVER_USER }}@${{ secrets.PRODUCTION_SERVER_IP }} << 'EOF'
            cd /opt/connect
            
            # Tag new image
            docker tag connect:${{ github.sha }} connect:latest
            
            # Update docker-compose with new image
            export COMPOSE_FILE=docker-compose.production.yml
            
            # Load environment variables
            set -a
            source /opt/connect/.env.production
            set +a
            
            # Discover the network name used by existing containers
            NETWORK_NAME=$(docker inspect connect_postgres --format='{{range $net,$v := .NetworkSettings.Networks}}{{$net}}{{end}}')
            echo "Using network: $NETWORK_NAME"
            
            # Run migrations using new image (no port binding)
            echo "Running database migrations with new image..."
            docker run --rm \
              --network "$NETWORK_NAME" \
              -e DATABASE_URL="postgresql://connect:${DB_PASSWORD}@postgres:5432/connect?schema=public" \
              -e DIRECT_URL="postgresql://connect:${DB_PASSWORD}@postgres:5432/connect?schema=public" \
              connect:latest \
              npm run db:migrate:deploy || {
              echo "❌ Migrations failed!"
              exit 1
            }
            echo "✓ Migrations completed successfully"
            
            # Blue-Green deployment
            if docker ps | grep -q connect_app1; then
              echo "Deploying to app2, switching traffic..."
              docker-compose up -d app2
              sleep 10
              
              # Health check
              if curl -f http://172.25.0.22:3002/api/health; then
                echo "App2 healthy, switching traffic..."
                # Update HAProxy or nginx config here
                docker-compose stop app1
                docker-compose up -d app1
              else
                echo "App2 health check failed!"
                docker-compose stop app2
                exit 1
              fi
            else
              echo "Deploying to app1..."
              docker-compose up -d app1
            fi
            
            echo "Deployment complete!"
          EOF
      
      - name: Run health checks
        run: |
          sleep 5
          for i in {1..5}; do
            if curl -f https://221.164.102.253/api/health; then
              echo "Health check passed!"
              exit 0
            fi
            echo "Health check failed, retrying..."
            sleep 5
          done
          echo "Health checks failed!"
          exit 1
      
      - name: Notify on success
        if: success()
        run: |
          echo "✅ Deployment successful!"
          echo "Version: ${{ github.sha }}"
          echo "Deployed by: ${{ github.actor }}"
      
      - name: Rollback on failure
        if: failure()
        run: |
          echo "❌ Deployment failed! Rolling back..."
          ssh -i ~/.ssh/deploy_key \
          ${{ secrets.PRODUCTION_SERVER_USER }}@${{ secrets.PRODUCTION_SERVER_IP }} \
          'cd /opt/connect && docker-compose restart app1 app2'

