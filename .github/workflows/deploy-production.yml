name: Deploy to Production

on:
  push:
    branches: [main]
  workflow_dispatch:
    inputs:
      skip_tests:
        description: 'Skip tests (emergency deploy)'
        required: false
        default: 'false'

jobs:
  test:
    name: Run Tests
    runs-on: ubuntu-latest
    if: github.event.inputs.skip_tests != 'true'
    
    services:
      postgres:
        image: postgres:16
        env:
          POSTGRES_USER: postgres
          POSTGRES_PASSWORD: postgres
          POSTGRES_DB: connect_test
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
        ports:
          - 6432:5432
    
    env:
      DATABASE_URL: postgresql://postgres:postgres@localhost:6432/connect_test
      DIRECT_URL: postgresql://postgres:postgres@localhost:6432/connect_test
      NODE_ENV: test
      ENCRYPTION_KEY: 0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef
      NEXTAUTH_SECRET: test_nextauth_secret_for_ci_testing_only
      NEXTAUTH_URL: http://localhost:3000
      JWT_SECRET: test_jwt_secret_for_ci_testing_only
      NAVER_CLIENT_ID: test_naver_client_id_for_ci
      NAVER_CLIENT_SECRET: test_naver_client_secret_for_ci
      KAKAO_CLIENT_ID: test_kakao_client_id_for_ci
      KAKAO_CLIENT_SECRET: test_kakao_client_secret_for_ci
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20.x'
          cache: 'npm'
      
      - name: Install dependencies
        run: npm ci
      
      - name: Install PostgreSQL client
        run: |
          sudo apt-get update
          sudo apt-get install -y postgresql-client
      
      - name: Wait for PostgreSQL
        run: |
          echo "Waiting for PostgreSQL to be ready..."
          for i in {1..30}; do
            if pg_isready -h localhost -p 6432 -U postgres; then
              echo "âœ“ PostgreSQL is ready!"
              break
            fi
            echo "Attempt $i/30: PostgreSQL not ready yet..."
            sleep 2
          done
          
          # Verify connection
          PGPASSWORD=postgres psql -h localhost -p 6432 -U postgres -d connect_test -c "SELECT version();"
      
      - name: Setup test database
        run: |
          echo "Generating Prisma client..."
          npx prisma generate
          
          echo "Pushing database schema..."
          npx prisma db push --skip-generate --accept-data-loss
          
          echo "Verifying database schema..."
          PGPASSWORD=postgres psql -h localhost -p 6432 -U postgres -d connect_test -c "\dt"
          
          echo "âœ“ Database setup complete"
      
      - name: Verify environment
        run: |
          echo "DATABASE_URL: $DATABASE_URL"
          echo "NODE_ENV: $NODE_ENV"
          echo "Prisma client location:"
          ls -la node_modules/.prisma/client/ || echo "Prisma client not found"
      
      - name: Run tests
        env:
          DATABASE_URL: postgresql://postgres:postgres@localhost:6432/connect_test
          DIRECT_URL: postgresql://postgres:postgres@localhost:6432/connect_test
        run: npm test -- --passWithNoTests
      
      - name: Run linter
        run: npm run lint

  build:
    name: Build Docker Image
    runs-on: ubuntu-latest
    needs: test
    if: always() && (needs.test.result == 'success' || needs.test.result == 'skipped')
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3
      
      - name: Build production image
        uses: docker/build-push-action@v5
        with:
          context: .
          file: ./Dockerfile.production
          push: false
          tags: connect:${{ github.sha }}
          cache-from: type=gha
          cache-to: type=gha,mode=max
          outputs: type=docker,dest=/tmp/connect-image.tar
      
      - name: Upload image artifact
        uses: actions/upload-artifact@v4
        with:
          name: docker-image
          path: /tmp/connect-image.tar
          retention-days: 1

  deploy:
    name: Deploy to Production Server
    runs-on: ubuntu-latest
    needs: build
    environment:
      name: production
      url: https://221.164.102.253
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Download image artifact
        uses: actions/download-artifact@v4
        with:
          name: docker-image
          path: /tmp
      
      - name: Load Docker image
        run: docker load --input /tmp/connect-image.tar
      
      - name: Setup SSH key
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.PRODUCTION_SERVER_SSH_KEY }}" > ~/.ssh/deploy_key
          chmod 600 ~/.ssh/deploy_key
          ssh-keyscan -H ${{ secrets.PRODUCTION_SERVER_IP }} >> ~/.ssh/known_hosts
      
      - name: Copy image to production
        run: |
          docker save connect:${{ github.sha }} | gzip | \
          ssh -i ~/.ssh/deploy_key \
          ${{ secrets.PRODUCTION_SERVER_USER }}@${{ secrets.PRODUCTION_SERVER_IP }} \
          'gunzip | docker load'
      
      - name: Deploy to production
        run: |
          ssh -i ~/.ssh/deploy_key \
          ${{ secrets.PRODUCTION_SERVER_USER }}@${{ secrets.PRODUCTION_SERVER_IP }} << 'EOF'
            cd /opt/connect

            # Tag new image
            docker tag connect:${{ github.sha }} connect:latest

            # Deploy using docker-compose (migrations run automatically inside containers)
            export COMPOSE_FILE=docker-compose.production.yml

            # Blue-Green deployment
            if docker ps | grep -q connect_app1; then
              echo "ðŸ”„ Deploying to app2 first (blue-green deployment)..."
              docker-compose up -d app2

              # Wait for health check (migrations run automatically inside container)
              echo "â³ Waiting for app2 to be healthy (including migrations)..."
              timeout 180 sh -c 'until curl -sf http://172.25.0.22:3002/api/health; do sleep 5; done'

              # Switch traffic and update app1
              echo "âœ… App2 healthy. Updating app1..."
              docker-compose stop app1
              docker-compose up -d app1

              # Wait for app1
              echo "â³ Waiting for app1 to be healthy..."
              timeout 180 sh -c 'until curl -sf http://172.25.0.21:3001/api/health; do sleep 5; done'

              echo "âœ… Both instances healthy and running!"
            else
              echo "ðŸ†• First deployment - starting both instances..."
              docker-compose up -d app1 app2

              # Wait for both to be healthy
              timeout 180 sh -c 'until curl -sf http://172.25.0.21:3001/api/health; do sleep 5; done'
              timeout 180 sh -c 'until curl -sf http://172.25.0.22:3002/api/health; do sleep 5; done'
            fi

            echo "ðŸŽ‰ Deployment complete!"
          EOF
      
      - name: Run health checks
        run: |
          sleep 5
          # Check app1 on its direct port (no reverse proxy configured yet)
          for i in {1..5}; do
            if curl -f http://221.164.102.253:3001/api/health; then
              echo "âœ… App1 health check passed!"
              exit 0
            fi
            echo "Health check failed, retrying..."
            sleep 5
          done
          echo "Health checks failed!"
          exit 1
      
      - name: Notify on success
        if: success()
        run: |
          echo "âœ… Deployment successful!"
          echo "Version: ${{ github.sha }}"
          echo "Deployed by: ${{ github.actor }}"
      
      - name: Rollback on failure
        if: failure()
        run: |
          echo "âŒ Deployment failed! Rolling back..."
          ssh -i ~/.ssh/deploy_key \
          ${{ secrets.PRODUCTION_SERVER_USER }}@${{ secrets.PRODUCTION_SERVER_IP }} \
          'cd /opt/connect && docker-compose restart app1 app2'

