name: Deploy to Production

on:
  push:
    branches: [main]
  workflow_dispatch:
    inputs:
      skip_tests:
        description: 'Skip tests (emergency deploy)'
        required: false
        default: 'false'

jobs:
  test:
    name: Run Tests
    runs-on: ubuntu-latest
    if: github.event.inputs.skip_tests != 'true'
    
    services:
      postgres:
        image: postgres:16
        env:
          POSTGRES_USER: postgres
          POSTGRES_PASSWORD: postgres
          POSTGRES_DB: connect_test
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
        ports:
          - 6432:5432

      redis:
        image: redis:7-alpine
        options: >-
          --health-cmd "redis-cli ping"
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
        ports:
          - 6379:6379

    env:
      DATABASE_URL: postgresql://postgres:postgres@localhost:6432/connect_test
      DIRECT_URL: postgresql://postgres:postgres@localhost:6432/connect_test
      REDIS_CACHE_URL: redis://localhost:6379/0
      NODE_ENV: test
      ENCRYPTION_KEY: 0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef
      NEXTAUTH_SECRET: test_nextauth_secret_for_ci_testing_only
      NEXTAUTH_URL: http://localhost:3000
      JWT_SECRET: test_jwt_secret_for_ci_testing_only
      NAVER_CLIENT_ID: test_naver_client_id_for_ci
      NAVER_CLIENT_SECRET: test_naver_client_secret_for_ci
      KAKAO_CLIENT_ID: test_kakao_client_id_for_ci
      KAKAO_CLIENT_SECRET: test_kakao_client_secret_for_ci
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20.x'
          cache: 'npm'
      
      - name: Install dependencies
        run: npm ci
      
      - name: Install PostgreSQL client
        run: |
          sudo apt-get update
          sudo apt-get install -y postgresql-client
      
      - name: Wait for PostgreSQL
        run: |
          echo "Waiting for PostgreSQL to be ready..."
          for i in {1..30}; do
            if pg_isready -h localhost -p 6432 -U postgres; then
              echo "‚úì PostgreSQL is ready!"
              break
            fi
            echo "Attempt $i/30: PostgreSQL not ready yet..."
            sleep 2
          done
          
          # Verify connection
          PGPASSWORD=postgres psql -h localhost -p 6432 -U postgres -d connect_test -c "SELECT version();"
      
      - name: Setup test database
        run: |
          echo "Generating Prisma client..."
          npx prisma generate
          
          echo "Pushing database schema..."
          npx prisma db push --skip-generate --accept-data-loss
          
          echo "Verifying database schema..."
          PGPASSWORD=postgres psql -h localhost -p 6432 -U postgres -d connect_test -c "\dt"
          
          echo "‚úì Database setup complete"
      
      - name: Verify environment
        run: |
          echo "DATABASE_URL: $DATABASE_URL"
          echo "NODE_ENV: $NODE_ENV"
          echo "Prisma client location:"
          ls -la node_modules/.prisma/client/ || echo "Prisma client not found"
      
      - name: Run tests
        env:
          DATABASE_URL: postgresql://postgres:postgres@localhost:6432/connect_test
          DIRECT_URL: postgresql://postgres:postgres@localhost:6432/connect_test
        run: npm test -- --passWithNoTests
      
      - name: Run linter
        run: npm run lint

  build:
    name: Build Docker Image
    runs-on: ubuntu-latest
    needs: test
    if: always() && (needs.test.result == 'success' || needs.test.result == 'skipped')
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3
      
      - name: Build production image
        uses: docker/build-push-action@v5
        with:
          context: .
          file: ./Dockerfile.production
          push: false
          tags: connect:${{ github.sha }}
          cache-from: type=gha
          cache-to: type=gha,mode=max
          outputs: type=docker,dest=/tmp/connect-image.tar

      - name: Build scraper image
        uses: docker/build-push-action@v5
        with:
          context: .
          file: ./Dockerfile.scraper
          push: false
          tags: connect-scraper:${{ github.sha }}
          cache-from: type=gha
          cache-to: type=gha,mode=max
          outputs: type=docker,dest=/tmp/connect-scraper-image.tar

      - name: Verify scripts directory in images
        run: |
          echo "üîç Verifying scripts/ directory exists in Docker images..."

          # Load and check scraper image
          docker load --input /tmp/connect-scraper-image.tar
          if docker run --rm connect-scraper:${{ github.sha }} ls /app/scripts/ >/dev/null 2>&1; then
            echo "‚úÖ scripts/ exists in scraper image"
          else
            echo "‚ùå scripts/ missing from scraper image"
            exit 1
          fi

          # Load and check app image
          docker load --input /tmp/connect-image.tar
          if docker run --rm connect:${{ github.sha }} ls /app/scripts/ >/dev/null 2>&1; then
            echo "‚úÖ scripts/ exists in app image"
          else
            echo "‚ùå scripts/ missing from app image"
            exit 1
          fi

          echo "‚úÖ All images contain scripts/ directory"

      - name: Upload app image artifact
        uses: actions/upload-artifact@v4
        with:
          name: docker-image
          path: /tmp/connect-image.tar
          retention-days: 1

      - name: Upload scraper image artifact
        uses: actions/upload-artifact@v4
        with:
          name: docker-scraper-image
          path: /tmp/connect-scraper-image.tar
          retention-days: 1

  deploy:
    name: Deploy to Production Server
    runs-on: ubuntu-latest
    needs: build
    environment:
      name: production
      url: https://221.164.102.253
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Download app image artifact
        uses: actions/download-artifact@v4
        with:
          name: docker-image
          path: /tmp

      - name: Download scraper image artifact
        uses: actions/download-artifact@v4
        with:
          name: docker-scraper-image
          path: /tmp

      - name: Load Docker images
        run: |
          docker load --input /tmp/connect-image.tar
          docker load --input /tmp/connect-scraper-image.tar
      
      - name: Setup SSH key
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.PRODUCTION_SERVER_SSH_KEY }}" > ~/.ssh/deploy_key
          chmod 600 ~/.ssh/deploy_key
          ssh-keyscan -H ${{ secrets.PRODUCTION_SERVER_IP }} >> ~/.ssh/known_hosts

      - name: Copy configuration files to production
        run: |
          echo "Copying docker-compose.production.yml to production server..."
          scp -i ~/.ssh/deploy_key \
          docker-compose.production.yml \
          ${{ secrets.PRODUCTION_SERVER_USER }}@${{ secrets.PRODUCTION_SERVER_IP }}:/opt/connect/

          echo "‚úì Configuration files copied successfully"

      - name: Copy images to production
        run: |
          echo "Transferring app image..."
          docker save connect:${{ github.sha }} | gzip | \
          ssh -i ~/.ssh/deploy_key \
          ${{ secrets.PRODUCTION_SERVER_USER }}@${{ secrets.PRODUCTION_SERVER_IP }} \
          'gunzip | docker load'

          echo "Transferring scraper image..."
          docker save connect-scraper:${{ github.sha }} | gzip | \
          ssh -i ~/.ssh/deploy_key \
          ${{ secrets.PRODUCTION_SERVER_USER }}@${{ secrets.PRODUCTION_SERVER_IP }} \
          'gunzip | docker load'
      
      - name: Deploy to production
        run: |
          ssh -i ~/.ssh/deploy_key \
          ${{ secrets.PRODUCTION_SERVER_USER }}@${{ secrets.PRODUCTION_SERVER_IP }} << 'EOF'
            cd /opt/connect

            # Tag new images
            docker tag connect:${{ github.sha }} connect:latest
            docker tag connect-scraper:${{ github.sha }} connect-scraper:latest

            # Deploy using docker-compose (migrations run automatically inside containers)
            export COMPOSE_FILE=docker-compose.production.yml

            # Blue-Green deployment for app instances
            if docker ps | grep -q connect_app1; then
              echo "üîÑ Deploying to app2 first (blue-green deployment)..."
              docker-compose --env-file .env.production up -d app2

              # Wait for health check (migrations run automatically inside container)
              echo "‚è≥ Waiting for app2 to be healthy (including migrations)..."
              timeout 180 sh -c 'until curl -sf http://172.25.0.22:3002/api/health; do sleep 5; done'

              # Switch traffic and update app1
              echo "‚úÖ App2 healthy. Updating app1..."
              docker-compose --env-file .env.production stop app1
              docker-compose --env-file .env.production up -d app1

              # Wait for app1
              echo "‚è≥ Waiting for app1 to be healthy..."
              timeout 180 sh -c 'until curl -sf http://172.25.0.21:3001/api/health; do sleep 5; done'

              echo "‚úÖ Both app instances healthy!"
            else
              echo "üÜï First deployment - starting both app instances..."
              docker-compose --env-file .env.production up -d app1 app2

              # Wait for both to be healthy
              timeout 180 sh -c 'until curl -sf http://172.25.0.21:3001/api/health; do sleep 5; done'
              timeout 180 sh -c 'until curl -sf http://172.25.0.22:3002/api/health; do sleep 5; done'
              echo "‚úÖ Both app instances healthy!"
            fi

            # Deploy scraper (with fresh code and health checks)
            echo "üîÑ Deploying scraper..."
            docker-compose --env-file .env.production up -d scraper

            # Wait for scraper to be healthy
            echo "‚è≥ Waiting for scraper to be healthy..."
            for i in {1..30}; do
              if docker inspect connect_scraper --format='{{.State.Health.Status}}' 2>/dev/null | grep -q "healthy"; then
                echo "‚úÖ Scraper is healthy!"
                break
              fi
              echo "Attempt $i/30: Scraper not healthy yet..."
              sleep 5
            done

            # Verify scraper is running
            if docker ps | grep -q connect_scraper; then
              echo "‚úÖ Scraper is running"
            else
              echo "‚ùå Scraper failed to start"
              docker logs connect_scraper --tail 50
              exit 1
            fi

            echo "üéâ Deployment complete! (App1, App2, Scraper)"
          EOF
      
      - name: Run health checks
        run: |
          echo "‚è≥ Waiting for containers to be fully ready..."
          sleep 10

          # Check app1 on its direct port (allow 3 minutes for migrations + startup)
          for i in {1..36}; do
            if curl -f http://221.164.102.253:3001/api/health; then
              echo "‚úÖ App1 health check passed!"
              exit 0
            fi
            echo "Attempt $i/36: Health check failed, retrying..."
            sleep 5
          done

          echo "‚ùå Health checks failed after 3 minutes!"
          exit 1
      
      - name: Notify on success
        if: success()
        run: |
          echo "‚úÖ Deployment successful!"
          echo "Version: ${{ github.sha }}"
          echo "Deployed by: ${{ github.actor }}"
      
      - name: Rollback on failure
        if: failure()
        run: |
          echo "‚ùå Deployment failed! Rolling back..."
          ssh -i ~/.ssh/deploy_key \
          ${{ secrets.PRODUCTION_SERVER_USER }}@${{ secrets.PRODUCTION_SERVER_IP }} \
          'cd /opt/connect && docker-compose --env-file .env.production restart app1 app2 scraper'

